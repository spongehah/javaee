### 1 Synchronized加锁和ReentrantLock加锁有什么区别？

synchronized 和 ReentrantLock 都是 Java 中提供的可重入锁：

- **底层实现不同**：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。
- **用法不同**：synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。
- **获取锁和释放锁方式不同**：synchronized 会自动加锁和释放锁，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。而 ReentrantLock 需要手动加锁和释放锁
- **锁类型不同**：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。
- **响应中断不同**：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。
- **通知机制不同**：ReentrantLock 可实现选择性通知（锁可以绑定多个条件），synchronized 只能通知所有对象

### 2 线程池为什么核心线程满了之后是先加入阻塞队列而不是直接加到总线程？

- 线程池创建线程需要获取mainlock这个全局锁，会影响并发效率，所以使用阻塞队列把第一步创建核心线程与第三步创建最大线程隔离开来，起一个缓冲的作用。
- 引入阻塞队列，是为了在执行execute()方法时，尽可能的避免获取全局锁。

### 3 关闭线程池的方法

调用ExecutorService的以下两个方法：

1. shutdown()：
   - **优雅关闭：**启动线程池的关闭序列，线程池不再接收新的任务，等待所有已提交的任务执行完毕
2. shutdownNow()：
   - **尝试立即关闭：**尝试停止 正在执行 和 提交 的所有任务，并返回等待执行的任务链表。并不能保证能立即停止所有任务，因为有些任务正在执行关键操作，并不能被立即中断。

### 4 shutdowmNow()为什么有些任务无法取消？

shutdowmNow()方法能否成功取消任务，**取决于 任务自身的中断机制**。该方法是使用 Thread.interrupt() 方法尝试中断所有正在运行的任务。

然而 interrupt() 是一种中断协商机制，并不是强制终止，需要看线程自身的实现机制。如果该线程**没有实现对中断的响应**，或者**正在执行 阻塞** 操作，并不能立即停止该线程的执行。

### 5 sleep和wait的区别是什么？

**相同点：**

- `sleep()` 和 `wait()` 调用都会暂停当前线程并让出 `CPU`

**不同点：**

- 定义位置不同：`sleep()` 是线程类（`Thread`）的方法；`wait()` 是顶级类 `Object` 的方法；
- 调用地方不同：`sleep` 方法可以在任何地方使用；`wait` 方法则只能在同步方法或同步块中使用；
- 锁资源释放方式不同：`sleep` 方法只让出了CPU，没有释放同步资源锁！`wait`方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了`notify`方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。
- 恢复方式不同：sleep调用后停止运行期间仍持有同步锁，所以到时间会继续执行；wait调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，再次获得对象锁后才会进入运行状态，在没有获取对象锁之前不会继续执行；
- 异常捕获：sleep需要捕获或者抛出异常，而wait/notify/notifyAll则不需要。

### 6 为什么wait要包在同步块？

Java中的`wait()`方法需要在同步块（synchronized block）中调用的原因是因为`wait()`方法会释放对象的锁，而在同步块中可以**确保线程在调用`wait()`方法前持有对象的锁**，从而避免多线程执行时的竞争和冲突。

具体原因如下：

- **线程安全**：在同步块中调用`wait()`方法可以确保线程在调用`wait()`前已经获取了对象的锁，避免多线程之间的竞争和数据不一致性问题。（**已经获得锁才需要wait**）
- **对象监视器**：`wait()`方法会释放对象的监视器（monitor），其他线程可以获取该对象的监视器并执行同步操作，确保线程之间的协作和同步。
- **唤醒机制**：当调用`wait()`方法后，线程会进入等待状态，只有在其他线程调用`notify()`或`notifyAll()`方法唤醒该线程时，线程才会继续执行。在同步块中调用`wait()`可以保证线程被正确唤醒。（**被唤醒后可以直接进入同步块对应的锁池进行排队**）





















