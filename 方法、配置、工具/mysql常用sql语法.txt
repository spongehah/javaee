一、DQL:对表数据进行查询:
查：select 字段名
    from xxx
    (join xxx on 条件 join...)
    where 条件
    group by xxx
    having 分组分组后条件
    order by 字段名
    limit 开始条数(从0),条数;

    模糊查询：like ''
		    %:匹配多个字段
		    _:匹配一个字段

	  distinct : 除去重复数据

----------------------------------------------------------------------------
二、DML:对表数据进行增删改：
(事务*****):
增：insert into xxx (字段名1,字段名2,...) values(,,),(,,);
删：delete from xxx where 条件;(效率低，支持回滚)
    truncate table xxx;(效率高，不支持回滚)
改：update xxx set 字段名1 = xx,字段名2 = xx,... where 条件

----------------------------------------------------------------------------
三、DDL:对表结构进行操作:
创建表:
	create table xxx(
	字段名1 数据类型,
	字段名2 数据类型,
	字段名3 数据类型
	);

	约束：
	     not null;    不能为空
	     unique;      数据唯一
	     primary key; 主键 == not null + unique
	     foreign key; 外键

	     联合唯一：unique(字段1,字段2...)
	     primary key：单一主键/复合主键，只能有一个主键，要么单一要么复合
	     foreign key：primary key(外键字段) references xxx(继承的字段);
	     外键字段可以为空，但被继承的字段必须unique！
删除表：
	drop table xxx;
	drop table if exists xxx;
对表结构进行增删改:
	alter:对字段名进行增删改

----------------------------------------------------------------------------
四、事务：(transaction)
     提交事务：commit;
     回滚事务：rollback;
     取消MySQL默认自动提交事务：start transaction;

修改MySQL事务隔离级别：
     set global transaction isolation level read uncommited;
					    read commited
					    repeatable read
					    serializable

----------------------------------------------------------------------------
五、存储引擎(了解):
	MyISAM：文件为只读，可压缩，节省空间
	InnoDB：安全性高
	MEMORY：存储在内存中，查询速度最快，关机后数据丢失

----------------------------------------------------------------------------
六、索引index(目录)：
	添加在字段上，提高扫描效率
	索引也需要排序(和TreeMap数据结构相同)，可以区间查找
	TreeMap底层是一个二叉树的数据结构，采用中序遍历的方式存取数据

	主键和unique的约束会自动创建索引对象
	添加索引的条件：
	      1.数据量庞大(需要测试)
	      2.该字段经常出现在where的后面，也就是总是会被扫描
	      3.该字段很少的DML操作(因为DML之后，索引需要重新排序)

	      建议：1.不要随意添加索引，因为索引也是需要维护的，
	            太多的话反而会降低系统的性能
		    2.建议通过主键和unique约束的字段查询，效率较高
	
	创建索引：create index emp_ename_index on emp(ename);
	删除索引：drop index emp_ename_index on emp;
	查看是否使用索引：explain select * from emp where ename = 'KING';

	索引有失效的时候，什么时候索引失效呢？
	
	失效的第1种情况：
		select * from emp where ename like '%T';

		ename上即使添加了索引，也不会走索引，为什么？
			原因是因为模糊匹配当中以“%”开头了！
			尽量避免模糊查询的时候以“%”开始。
			这是一种优化的手段/策略。

	失效的第2种情况：
		mysql> explain select * from emp where ename = 'KING' or job = 'MANAGER';

		使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有
		索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个
		字段上的索引也会实现。所以这就是为什么不建议使用or的原因。

	失效的第3种情况：
		create index emp_job_sal_index on emp(job,sal);
		mysql> explain select * from emp where sal = 800;

		使用复合索引的时候，没有使用左侧的列查找，索引失效
		什么是复合索引？
			两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。

	失效的第4种情况：
		在where当中索引列参加了运算，索引失效。
		mysql> create index emp_sal_index on emp(sal);
		mysql> explain select * from emp where sal+1 = 800;

	失效的第5种情况：
		在where当中索引列使用了函数
		explain select * from emp where lower(ename) = 'smith';

	失效的第6...
	失效的第7...

	索引是各种数据库进行优化的重要手段。优化的时候优先考虑的因素就是索引。
	索引在数据库当中分了很多类？
	单一索引：一个字段上添加索引。
	复合索引：两个字段或者更多的字段上添加索引。

	主键索引：主键上添加索引。
	唯一性索引：具有unique约束的字段上添加索引。
	.....

	注意：唯一性比较弱的字段上添加索引用处不大。

----------------------------------------------------------------------------
七、视图(view)

7.1、什么是视图？
	view:站在不同的角度去看待同一份数据。

7.2、怎么创建视图对象？怎么删除视图对象？

	表复制：
	mysql> create table dept2 as select * from dept;

	dept2表中的数据：
	mysql> select * from dept2;
	+--------+------------+----------+
	| DEPTNO | DNAME      | LOC      |
	+--------+------------+----------+
	|     10 | ACCOUNTING | NEW YORK |
	|     20 | RESEARCH   | DALLAS   |
	|     30 | SALES      | CHICAGO  |
	|     40 | OPERATIONS | BOSTON   |
	+--------+------------+----------+

	创建视图对象：
		create view dept2_view as select * from dept2;
	
	删除视图对象：
		drop view dept2_view;
	
	注意：只有DQL语句才能以view的形式创建。
		create view view_name as 这里的语句必须是DQL语句;

7.3、用视图做什么？

	我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致
	原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）

	//面向视图查询
	select * from dept2_view; 

	// 面向视图插入
	insert into dept2_view(deptno,dname,loc) values(60,'SALES', 'BEIJING');

	// 查询原表数据
	mysql> select * from dept2;
	+--------+------------+----------+
	| DEPTNO | DNAME      | LOC      |
	+--------+------------+----------+
	|     10 | ACCOUNTING | NEW YORK |
	|     20 | RESEARCH   | DALLAS   |
	|     30 | SALES      | CHICAGO  |
	|     40 | OPERATIONS | BOSTON   |
	|     60 | SALES      | BEIJING  |
	+--------+------------+----------+

	// 面向视图删除
	mysql> delete from dept2_view;

	// 查询原表数据
	mysql> select * from dept2;
	Empty set (0.00 sec)
	

	// 创建视图对象
	create view 
		emp_dept_view
	as
		select 
			e.ename,e.sal,d.dname
		from
			emp e
		join
			dept d
		on
			e.deptno = d.deptno;

	// 查询视图对象
	mysql> select * from emp_dept_view;
	+--------+---------+------------+
	| ename  | sal     | dname      |
	+--------+---------+------------+
	| CLARK  | 2450.00 | ACCOUNTING |
	| KING   | 5000.00 | ACCOUNTING |
	| MILLER | 1300.00 | ACCOUNTING |
	| SMITH  |  800.00 | RESEARCH   |
	| JONES  | 2975.00 | RESEARCH   |
	| SCOTT  | 3000.00 | RESEARCH   |
	| ADAMS  | 1100.00 | RESEARCH   |
	| FORD   | 3000.00 | RESEARCH   |
	| ALLEN  | 1600.00 | SALES      |
	| WARD   | 1250.00 | SALES      |
	| MARTIN | 1250.00 | SALES      |
	| BLAKE  | 2850.00 | SALES      |
	| TURNER | 1500.00 | SALES      |
	| JAMES  |  950.00 | SALES      |
	+--------+---------+------------+

	// 面向视图更新
	update emp_dept_view set sal = 1000 where dname = 'ACCOUNTING';

	// 原表数据被更新
	mysql> select * from emp;
	+-------+--------+-----------+------+------------+---------+---------+--------+
	| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
	+-------+--------+-----------+------+------------+---------+---------+--------+
	|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |
	|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
	|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
	|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
	|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
	|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
	|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     10 |
	|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |
	|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     10 |
	|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
	|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |
	|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |
	|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |
	|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     10 |
	+-------+--------+-----------+------+------------+---------+---------+--------+

7.4、视图对象在实际开发中到底有什么用？《方便，简化开发，利于维护》

		create view 
			emp_dept_view
		as
			select 
				e.ename,e.sal,d.dname
			from
				emp e
			join
				dept d
			on
				e.deptno = d.deptno;
		
		
		假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。
		每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？
			可以把这条复杂的SQL语句以视图对象的形式新建。
			在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。
			并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要
			修改视图对象所映射的SQL语句。
		
		我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。
		可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是
		存储在硬盘上的，不会消失。

		再提醒一下：
			视图对应的语句只能是DQL语句。
			但是视图对象创建完成之后，可以对视图进行增删改查等操作。

		小插曲：
			增删改查，又叫做：CRUD。
			CRUD是在公司中程序员之间沟通的术语。一般我们很少说增删改查。
			一般都说CRUD。

			C:Create（增）
			R:Retrive（查：检索）
			U:Update（改）
			D:Delete（删）

----------------------------------------------------------------------------
八、DBA常用命令(了解)

	重点掌握：
		数据的导入和导出（数据的备份）
		其它命令了解一下即可。（这个培训日志文档留着，以后忘了，可以打开文档复制粘贴。）
	
	数据导出？
		注意：在windows的dos命令窗口中：
			mysqldump bjpowernode>D:\bjpowernode.sql -uroot -p123456
		
		可以导出指定的表吗？
			mysqldump bjpowernode emp>D:\bjpowernode.sql -uroot -p123456

	数据导入？
		注意：需要先登录到mysql数据库服务器上。
		然后创建数据库：create database bjpowernode;
		使用数据库：use bjpowernode
		然后初始化数据库：source D:\bjpowernode.sql

----------------------------------------------------------------------------
九、数据库设计三范式

9.1、什么是数据库设计范式？
	数据库表的设计依据。教你怎么进行数据库表的设计。

9.2、数据库设计范式共有？
	3个。
	第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。

	第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，
	不要产生部分依赖。

	第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，
	不要产生传递依赖。

	声明：三范式是面试官经常问的，所以一定要熟记在心！

	设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。

9.3、第一范式
	最核心，最重要的范式，所有表的设计都需要满足。
	必须有主键，并且每一个字段都是原子性不可再分。

	学生编号 学生姓名 联系方式
	------------------------------------------
	1001		张三		zs@gmail.com,1359999999
	1002		李四		ls@gmail.com,13699999999
	1001		王五		ww@163.net,13488888888

	以上是学生表，满足第一范式吗？
		不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话
	
	学生编号(pk) 学生姓名	邮箱地址			联系电话
	----------------------------------------------------
	1001				张三		zs@gmail.com	1359999999
	1002				李四		ls@gmail.com	13699999999
	1003				王五		ww@163.net		13488888888

9.4、第二范式：
	建立在第一范式的基础之上，
	要求所有非主键字段必须完全依赖主键，不要产生部分依赖。

	学生编号 学生姓名 教师编号 教师姓名
	----------------------------------------------------
	1001			张三		001		王老师
	1002			李四		002		赵老师
	1003			王五		001		王老师
	1001			张三		002		赵老师

	这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）
	这是非常典型的：多对多关系！

	分析以上的表是否满足第一范式？
		不满足第一范式。
	
	怎么满足第一范式呢？修改

	学生编号+教师编号(pk)		学生姓名  教师姓名
	----------------------------------------------------
	1001			001				张三			王老师
	1002			002				李四			赵老师
	1003			001				王五			王老师
	1001			002				张三			赵老师

	学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）
	经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？
		不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。
		产生部分依赖有什么缺点？
			数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。
	
	为了让以上的表满足第二范式，你需要这样设计：
		使用三张表来表示多对多的关系！！！！
		学生表
		学生编号(pk)		学生名字
		------------------------------------
		1001					张三
		1002					李四
		1003					王五
		
		教师表
		教师编号(pk)		教师姓名
		--------------------------------------
		001					王老师
		002					赵老师

		学生教师关系表
		id(pk)			学生编号(fk)			教师编号(fk)
		------------------------------------------------------
		1						1001						001
		2						1002						002
		3						1003						001
		4						1001						002
	

	背口诀：
		多对多怎么设计？
			多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！


9.5、第三范式
	第三范式建立在第二范式的基础之上
	要求所有非主键字典必须直接依赖主键，不要产生传递依赖。

	学生编号（PK） 学生姓名 班级编号  班级名称
	---------------------------------------------------------
		1001				张三		01			一年一班
		1002				李四		02			一年二班
		1003				王五		03			一年三班
		1004				赵六		03			一年三班
	
	以上表的设计是描述：班级和学生的关系。很显然是1对多关系！
	一个教室中有多个学生。

	分析以上表是否满足第一范式？
		满足第一范式，有主键。
	
	分析以上表是否满足第二范式？
		满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。
	
	分析以上表是否满足第三范式？
		第三范式要求：不要产生传递依赖！
		一年一班依赖01，01依赖1001，产生了传递依赖。
		不符合第三范式的要求。产生了数据的冗余。
	
	那么应该怎么设计一对多呢？

		班级表：一
		班级编号(pk)				班级名称
		----------------------------------------
		01								一年一班
		02								一年二班
		03								一年三班

		学生表：多

		学生编号（PK） 学生姓名 班级编号(fk)
		-------------------------------------------
		1001				张三			01			
		1002				李四			02			
		1003				王五			03			
		1004				赵六			03		
		
		背口诀：
			一对多，两张表，多的表加外键！！！！！！！！！！！！

9.6、总结表的设计？

	一对多：
		一对多，两张表，多的表加外键！！！！！！！！！！！！

	多对多：
		多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！

	一对一：
		一对一放到一张表中不就行了吗？为啥还要拆分表？
		在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。
		一对一怎么设计？
			没有拆分表之前：一张表
				t_user
				id		login_name		login_pwd		real_name		email				address........
				---------------------------------------------------------------------------
				1			zhangsan		123				张三				zhangsan@xxx
				2			lisi			123				李四				lisi@xxx
				...
			
			这种庞大的表建议拆分为两张：
				t_login 登录信息表
				id(pk)		login_name		login_pwd	
				---------------------------------
				1				zhangsan		123			
				2				lisi			123			

				t_user 用户详细信息表
				id(pk)		real_name		email				address........	login_id(fk+unique)
				-----------------------------------------------------------------------------------------
				100			张三				zhangsan@xxx								1
				200			李四				lisi@xxx										2


				口诀：一对一，外键唯一！！！！！！！！！！

9.7、嘱咐一句话：

	数据库设计三范式是理论上的。

	实践和理论有的时候有偏差。

	最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。

	因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）

	有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，
	并且对于开发人员来说，sql语句的编写难度也会降低。

	面试的时候把这句话说上：他就不会认为你是初级程序员了！