## 1 出现OOM

项目加上以下参数：

```shell
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/logs/oom_dump/java_pid<pid>.hprof
-XX:ErrorFile=/logs/oom_dump/xxx.log 
```

- **HeapDumpOnOutOfMemoryError** 指示 JVM 在遇到 **OutOfMemoryError** 错误时将 heap 转储到物理文件中。
- **HeapDumpPath** 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 `<pid>` 标记，则当前进程的进程 id 将附加到文件名中，并使用`.hprof`格式
- **ErrorFile** 将error日志单独记录到一份log文件，方便排查（也可以使用logback，在logback文件中指定log的分类生成目录）



解决思路：

1. 如果能从error定位到具体的代码行最好
2. 如果不能，则需要对生成的dump文件，使用`jvisualvm`进行分析，找到具体报错的代码行号
   - 查看dump文件中的大对象，看是否与对应行号代码的业务有关，再深入进行排查

> 期间结合 **监控链路** 与 **性能监控工具** 进行观察
> 性能监控工具：Pinoint、skywalking等

## 2 CPU占用过高的情况，该怎么排查和处理？

> 在Linux环境下，项目出现CPU占用过高的情况时，可以按照以下步骤进行排查和处理：
>
> 1. **定位高CPU占用的进程**：
>    - 使用`top`命令查看系统中CPU占用率最高的进程。
> 1. **分析进程中的线程**：
>    - 如果发现某个进程的CPU占用率特别高，可以使用`top -H -p [PID]`来查看该进程中各个线程的CPU占用情况。
>    - 找出占用CPU最高的线程ID。
> 1. **转换线程ID为16进制**：
>    - 使用`printf "%x\n" [线程ID]`命令将线程ID转换为16进制格式。
> 1. **获取线程堆栈信息**：
>    - 使用`jstack [进程PID] | grep [线程ID的16进制] -A 30`命令获取该线程的Java堆栈信息（如果是Java进程）。这可以帮助定位到具体的代码行或方法调用。
>    - 如果不是Java进程，可以使用`gdb`或其他相应的调试工具来获取线程的堆栈信息。
> 1. **分析代码和日志**：
>    - 根据堆栈信息，检查相关的代码逻辑，看是否有死循环、资源泄露、复杂计算等导致CPU占用过高的问题。
>    - 同时检查应用程序的日志，看是否有异常或错误信息与高CPU占用相关。
> 1. **处理措施**：
>    - 如果是代码问题，修复相应的bug或优化算法。
>    - 如果是配置问题，调整系统或应用程序的配置参数。
>    - 如果是资源不足，考虑增加硬件资源或优化资源分配。
>    - 如果是外部攻击，加强系统的安全防护措施。
